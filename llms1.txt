# Uniswap v4

- [v4 vs v3](https://docs.uniswap.org/contracts/v4/concepts/v4-vs-v3): While Uniswap v4's underlying concentrated liquidity is the same as Uniswap v3, there are some key differences in the architecture and accounting.
- [Flash Accounting](https://docs.uniswap.org/contracts/v4/concepts/flash-accounting): In previous versions of Uniswap, every time a swap was made - including multi-hop swap - tokens were transferred between Pool contracts for intermediate steps.
- [ERC-6909](https://docs.uniswap.org/contracts/v4/concepts/erc6909): Uniswap v4 uses ERC-6909 to further improve gas-efficiency on token claims and redemptions.
- [Hooks](https://docs.uniswap.org/contracts/v4/concepts/hooks): Uniswap v4 introduces Hooks, a system that allows developers to customize and extend the behavior of liquidity pools.
- [Subscribers](https://docs.uniswap.org/contracts/v4/concepts/subscribers): Subscribers, new in Uniswap v4, allow for liquidity-position owners to opt-in to a contract that receives _notifications_. The new design is intended to support _liquidity mining_, additional rewards given to in-range liquidity providers. Through notification logic, position owners do not need to risk their liquidity position and its underlying assets. In Uniswap v3, _liquidity mining_ was supported by fully transferring the liquidity position to an external contract; this old design would give the external contract full ownership and control of the liquidity position.
- [PoolManager](https://docs.uniswap.org/contracts/v4/concepts/PoolManager): In Uniswap v3, each liquidity pool was represented by a separate smart contract deployed through the Uniswapv3Factory contract. While this approach provided flexibility, it also led to increased gas costs for pool creation and multi-hop swaps.
- [Dynamic Fees](https://docs.uniswap.org/contracts/v4/concepts/dynamic-fees): Uniswap v4 introduces dynamic fees, allowing for flexible and responsive fee structures managed through hooks. This feature enables pools to adapt fees to changing market conditions, potentially improving liquidity provider profitability and overall market efficiency.
- [Integrated Routing with UniswapX](https://docs.uniswap.org/contracts/v4/concepts/integrated-routing-uniswap-x): The Uniswap Interface will be ramping up support for hooks in its standard routing system progressively over time. Hook builders looking to get immediate access to flow from the interface can do so by running a UniswapX filler for their hooked pools.
- [Deployments](https://docs.uniswap.org/contracts/v4/deployments): The Uniswap Protocol is made up of multiple contracts on many networks.
- [Unlock Callback & Deltas](https://docs.uniswap.org/contracts/v4/guides/unlock-callback): In order to have access to the liquidity inside the `PoolManager`, it needs to be _unlocked_ to begin with. After being unlocked, any number of operations can be executed, which at the end of must be _locked_ again. At this point, if there are any _non-zero deltas_, meaning the PoolManager is owed or owes tokens back to some address, the whole execution reverts. Otherwise, both parties have paid or received the right amount of tokens and the operations have successfully carried out.
- [Reading Pool State](https://docs.uniswap.org/contracts/v4/guides/read-pool-state): Unlike previous versions, v4 uses a different approach for storing and accessing pool data, which requires understanding the use of `StateLibrary` and `extsload`.
- [Custom Accounting](https://docs.uniswap.org/contracts/v4/guides/custom-accounting): These features are grouped together because they collectively represent the core of Uniswap v4’s customizability. They all relate to how pool state is managed and modified, working in tandem to allow developers to create highly tailored AMM experiences. From dynamic fee structures to unique bonding curves.
- [Swap routing](https://docs.uniswap.org/contracts/v4/guides/swap-routing): Uniswap v4 introduces a new architecture where all pools are managed by a single PoolManager contract. While the underlying architecture uses a callback system for swaps, developers can still use the Universal Router to execute swaps on v4 pools, just as you would for v2 or v3.
- [ERC-6909](https://docs.uniswap.org/contracts/v4/guides/ERC-6909): Uniswap v4 uses ERC-6909, a token standard that works alongside the protocol’s flash accounting system. This guide explains how ERC-6909 functions within v4, when to use mint versus burn operations, and how developers can implement them effectively.
- [Position Manager](https://docs.uniswap.org/contracts/v4/guides/position-manager): The Position Manager in v4 provides a streamlined way to manage liquidity positions through a command-based interface. Unlike previous versions where each operation required separate function calls, v4’s Position Manager uses a batched command pattern that allows multiple operations to be executed in a single transaction.
- [StateView](https://docs.uniswap.org/contracts/v4/guides/state-view): When building on **Uniswap v4**, you will often need to read pool state for both onchain and offchain use cases. Onchain contracts can directly invoke the **StateLibrary** to execute these reads during transactions, but offchain systems—such as frontends or analytics services—require a deployed contract with view functions. This is where **StateView** comes in.
- [Flash Accounting](https://docs.uniswap.org/contracts/v4/guides/flash-accounting): Flash accounting is v4’s mechanism for tracking token movements throughout a transaction. Unlike traditional token accounting which updates balances immediately after each operation, flash accounting accumulates changes (deltas) and settles them at the end of the transaction.
- [Access msg.sender Inside a Hook](https://docs.uniswap.org/contracts/v4/guides/accessing-msg.sender-using-hook): This is typically a router contract, such as a custom swap router or the Universal Router. The challenge is distinguishing between different routers and securely obtaining the original msg.sender.
- [Hook Deployment](https://docs.uniswap.org/contracts/v4/guides/hooks/hook-deployment): As mentioned in Concept of Hooks, hook contracts indicate their implemented functions by __encoding its behavior in the address of the contract__. The `PoolManager` uses these permissions to determine which hook functions to call for a given pool.
- [Overview](https://docs.uniswap.org/contracts/v4/overview): Uniswap v4 inherits all of the capital efficiency gains of Uniswap v3, but provides flexibility via *hooks* and gas optimizations across the entire lifecycle.
- [Create Pool](https://docs.uniswap.org/contracts/v4/quickstart/create-pool): Creating a pool on Uniswap v4 is permissionless and enables the trading of an asset. Uniswap v4 is a popular destination for creating markets due to its:
- [Setup](https://docs.uniswap.org/contracts/v4/quickstart/manage-liquidity/setup-liquidity): For users looking to interact with the canonical Uniswap v4 `PositionManager`, _v4-periphery_ is a required dependency
- [Mint Position](https://docs.uniswap.org/contracts/v4/quickstart/manage-liquidity/mint-position): Similar to Uniswap v3, liquidity positions are minted as ERC-721 tokens and depend on a *periphery* contract. v4's `PositionManager` contract will facilitate liquidity management
- [Increase Liquidity](https://docs.uniswap.org/contracts/v4/quickstart/manage-liquidity/increase-liquidity): Please note that `PositionManager` is a command-based contract, where integrators will be encoding commands and their corresponding parameters.
- [Decrease Liquidity](https://docs.uniswap.org/contracts/v4/quickstart/manage-liquidity/decrease-liquidity): Please note that `PositionManager` is a command-based contract, where integrators will be encoding commands and their corresponding parameters.
- [Collect Fees](https://docs.uniswap.org/contracts/v4/quickstart/manage-liquidity/collect): See the setup guide
- [Burn Position](https://docs.uniswap.org/contracts/v4/quickstart/manage-liquidity/burn-liquidity): To liquidate a position, the _burn_ functionality can be invoked. The funds in the position will be withdrawn and all the information of the underlying token will be cleared. Burning the position is a cost effective way to exit as a liquidity provider.
- [Batch Modify](https://docs.uniswap.org/contracts/v4/quickstart/manage-liquidity/batch-liquidity): As seen in previous guides, `PositionManager` is a command-based contract. This design is conducive to batching complex liquidity operations. For example, developers can encode efficient logic to move liquidity between two positions on entirely different Pools.
- [Swap](https://docs.uniswap.org/contracts/v4/quickstart/swap): Although it's technically possible to interact directly with the PoolManager contract for swaps, this approach is not recommended due to its complexity and potential inefficiencies. Instead, the Universal Router is the preferred method, as it abstracts away these complexities. By using the Universal Router, developers and users can ensure a more straightforward, efficient, and standardized approach to executing swaps on v4 pools, aligning with best practices for Uniswap interactions.
- [Set Up Local Environment](https://docs.uniswap.org/contracts/v4/quickstart/hooks/setup): Before writing the hook let's first have a local environment properly configured e.g. deploying pool manager, utility routers and test tokens.
- [Swap Hooks](https://docs.uniswap.org/contracts/v4/quickstart/hooks/swap): Swaps are the most common interaction with the Uniswap protocol. When it comes to swap there are two hook functions available to customize and extend its behavior:
- [Liquidity Hooks](https://docs.uniswap.org/contracts/v4/quickstart/hooks/liquidity): This guide will walk through on an example of adding and removing liquidity. There are four hook functions available to customize and extend these behavior:
- [AsyncSwap Hooks](https://docs.uniswap.org/contracts/v4/quickstart/hooks/async-swap): One feature enabled by custom accounting is​​​​‌ AsyncSwap swap. This feature allows hook developers to replace the v4 (v3-style) swap logic.
- [Subscriber](https://docs.uniswap.org/contracts/v4/quickstart/subscriber): For developers looking to support custom _liquidity mining_, Subscriber contracts can be used to receive notifications about position modifications or transfers.
- [IPoolManager](https://docs.uniswap.org/contracts/v4/reference/core/IPoolManager): The `IPoolManager` interface defines the main methods for interacting with the Uniswap V4 pool manager contract. It exposes the core _swap lifecycle_ operations
- [LiquidityAmounts](https://docs.uniswap.org/contracts/v4/reference/core/libraries/liquidity-amounts): The `LiquidityAmounts` library provides functions for computing liquidity amounts from token amounts and prices in Uniswap V4.
- [TransientStateLibrary](https://docs.uniswap.org/contracts/v4/reference/core/libraries/transient-state-library): The `TransientStateLibrary` is a crucial component of Uniswap V4, providing utility functions for managing transient state in the PoolManager contract. This library handles operations related to reserves, delta counts, and locking state, which are essential for the efficient and secure operation of the Uniswap V4 protocol.
- [BalanceDelta Guide](https://docs.uniswap.org/contracts/v4/reference/core/types/balancedelta-guide): `BalanceDelta` is a type used in Uniswap V4 to represent the balance changes of two tokens (token0 and token1). It tightly packs the two values in a single 256 bits. It is designed to efficiently store and manipulate these balance deltas, with the upper 128 bits representing the change in token0 (`amount0`) and the lower 128 bits representing the change in token1 (`amount1`).
- [BeforeSwapDelta Guide](https://docs.uniswap.org/contracts/v4/reference/core/types/beforeswapdelta-guide): `BeforeSwapDelta` is a custom type used in Uniswap V4 hook contracts to represent balance changes during swap operations. It is specifically designed to handle the return value of the `beforeSwap` hook and to be compatible with the `afterSwap` hook.
- [Currency Guide](https://docs.uniswap.org/contracts/v4/reference/core/types/currency-guide): `Currency` is a custom type that represents either native currency (ETH) or ERC20 tokens.
- [PoolKey Guide](https://docs.uniswap.org/contracts/v4/reference/core/types/poolkey-guide): `PoolKey` is a crucial struct in Uniswap V4 that uniquely identifies a liquidity pool. It encapsulates all the essential parameters that define a pool's characteristics.
- [Custom Error Selectors](https://docs.uniswap.org/contracts/v4/reference/errors/errors): | Error Selector | Hex Value | |-----------------------------------------------------|--------------| | `IPoolManager.CurrencyNotSettled.selector` | `0x5212cba1` | | `IPoolManager.PoolNotInitialized.selector` | `0x486aa307` | | `IPoolManager.AlreadyUnlocked.selector` | `0x5090d6c6` | | `IPoolManager.ManagerLocked.selector` | `0x54e3ca0d` | | `IPoolManager.TickSpacingTooLarge.selector` | `0xb02b5dc2` | | `IPoolManager.TickSpacingTooSmall.selector` | `0x16fe7696` | | `IPoolManager.CurrenciesOutOfOrderOrEqual.selector` | `0xeaa6c6eb` | | `IPoolManager.UnauthorizedDynamicLPFeeUpdate.selector` | `0x30d21641` | | `IPoolManager.SwapAmountCannotBeZero.selector` | `0xbe8b8507` | | `IPoolManager.NonZeroNativeValue.selector` | `0x19d245cf` |
